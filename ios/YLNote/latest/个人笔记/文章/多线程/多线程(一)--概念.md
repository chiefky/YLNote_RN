

# 1.线程相关技术概念

参考链接：https://www.jianshu.com/p/89f93c3ec926

## 1.1 CPU

> 引自维基百科[CPU](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8)中央处理器 （英语：Central Processing Unit，缩写：CPU），是计算机的主要设备之一，功能主要是解释计算机指令以及处理计算机软件中的数据。
>
> 计算机的可编程性主要是指对中央处理器的编程。
>
> 中央处理器、内部存储器和输入／输出设备是现代电脑的三大核心部件。
>
> 1970年代以前，中央处理器由多个独立单元构成，后来发展出由集成电路制造的中央处理器，这些高度收缩的组件就是所谓的微处理器，其中分出的中央处理器最为复杂的电路可以做成单一微小功能强大的单元。

`CPU`主要由**运算器、控制器、寄存器**三部分组成，从字面意思看就是运算器就是起着运算的作用，控制器就是负责发出`CPU`每条指令所需要的信息，寄存器就是保存运算或者指令的一些临时文件，这样可以保证更高的速度。
 `CPU`有着处理指令、执行操作、控制时间、处理数据四大作用，打个比喻来说，`CPU`就像我们的大脑，帮我们完成各种各样的生理活动。因此如果没有`CPU`，那么电脑就是一堆废物，无法工作。

#### 多个单核CPU和单个多核CPU

**一个核心同时只能处理一个线程，单核CPU只能实现并发，而不是并行**。

如果有2个线程，双核`CPU`，那这两个线程是并行的，如果有三个线程，那么就还是并发的。

#### 并发 & 并行

并发的关键是你有处理多个任务的能力，不一定要同时。
 并行的关键是你有同时处理多个任务的能力。
 **并发是一种能力，处理多个任务的能力。并行是状态，多个任务同时执行的状态。**
 可以看到并发和并行并不是同一类概念，所以不具有比较性，并发包含并行，就比如水果是包含西瓜一样。并发的不一定是并行，并行的一定是并发。



## 1.2 进程

在`iOS`系统中，一个`APP`的运行实体代表一个进程。一个进程有独立的内存空间、系统资源、端口等。在进程中可以生成多个线程、这些线程可以共享进程中的资源。

进程是线程的容器，而线程用来执行任务。在iOS中是单进程开发，一个进程就是一个app，进程之间是相互独立的。

打个比方，`CPU`好比是一个工厂，进程是一个车间，线程是车间里面的工人。车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。

#### iOS中进程间的通信

`iOS`系统是相对封闭的系统，`App`各自在各自的沙盒（sandbox）中运行，每个`App`都只能读取`iPhone`上`iOS`系统为该应用程序程序创建的文件夹`AppData`下的内容，不能随意跨越自己的沙盒去访问别的`App`沙盒中的内容。
 所以`iOS`的系统中进行`App`间通信的方式也比较固定，常见的`App`间通信方式以及使用场景总结如下。

1. Port

   > 上层封装为`NSMachPort` : `Foundation`层
   >  中层封装为`CFMachPort` ： `Core Foundation`层
   >  下层封装为`Mach Ports` : `Mach`内核层（线程、进程都可使用它进行通信）
   >
   > 一个`App1`在本地的端口`port1234`进行`TCP`的`bind`和`listen`，另外一个`App2`在同一个端口`port1234`发起`TCP`的`connect`连接，这样就可以建立正常的`TCP`连接，进行`TCP`通信了，那么就想传什么数据就可以传什么数据了。但是有一个限制，就是要求两个`App`进程都在活跃状态，而没有被后台杀死。尴尬的一点是`iOS`系统会给每个`TCP`在后台`600`秒的网络通信时间，`600`秒后`APP`会进入休眠状态。

2. URL Scheme

   > 这个是`iOS` `App`通信最常用到的通信方式，`App1`通过`openURL`的方法跳转到`App2`，并且在`URL`中带上想要的参数，有点类似`http`的`get`请求那样进行参数传递。这种方式是使用最多的最常见的，使用方法也很简单只需要源`App1`在`info.plist`中配置`LSApplicationQueriesSchemes`，指定目标`App2`的`scheme`；然后在目标`App2`的`info.plist`中配置好`URL types`，表示该`App`接受何种`URL Scheme`的唤起。
   >
   > 典型的使用场景就是各开放平台`SDK`的分享功能，如分享到微信朋友圈微博等，或者是支付场景。比如从滴滴打车结束行程跳转到微信进行支付。

3. Keychain

   > `iOS`系统的`Keychain`是一个安全的存储容器，它本质上就是一个`sqllite`数据库，它的位置存储在`/private/var/Keychains/keychain-2.db`，不过它所保存的所有数据都是经过加密的，可以用来为不同的`App`保存敏感信息，比如用户名，密码等。`iOS`系统自己也用`Keychain`来保存`VPN`凭证和`Wi-Fi`密码。它是独立于每个`App`的沙盒之外的，所以即使`App`被删除之后，`Keychain`里面的信息依然存在。
   >
   > 基于安全和独立于`App`沙盒的两个特性，`Keychain`主要用于给`App`保存登录和身份凭证等敏感信息，这样只要用户登录过，即使用户删除了`App`重新安装也不需要重新登录。
   >
   > 那`Keychain`用于`App`间通信的一个典型场景也和`App`的登录相关，就是统一账户登录平台。使用同一个账号平台的多个`App`，只要其中一个`App`用户进行了登录，其他app就可以实现自动登录不需要用户多次输入账号和密码。一般开放平台都会提供登录`SDK`，在这个`SDK`内部就可以把登录相关的信息都写到`Keychain`中，这样如果多个`App`都集成了这个`SDK`，那么就可以实现统一账户登录了。

4. UIPasteboard

   >  `UIPasteboard`是剪切板功能，因为`iOS`的原生控件`UITextView`，`UITextField` 、`UIWebView`，我们在使用时如果长按，就会出现复制、剪切、选中、全选、粘贴等功能，这个就是利用了系统剪切板功能来实现的。而每一个App都可以去访问系统剪切板，所以就能够通过系统剪贴板进行`App`间的数据传输了

5. UIDocumentInteractionController

   > `UIDocumentInteractionController`主要是用来实现同设备上`App`之间的共享文档，以及文档预览、打印、发邮件和复制等功能。它的使用非常简单.
   >
   > 首先通过调用它唯一的类方法`interactionControllerWithURL:`，并传入一个`URL(NSURL)`，为你想要共享的文件来初始化一个实例对象。然后`UIDocumentInteractionControllerDelegate`，然后显示菜单和预览窗口。

6. AirDrop

   > `iOS`并没有直接提供`AirDrop`的实现接口，但是使用`UIActivityViewController`的方法唤起`AirDrop`，进行数据交互。

7. UIActivityViewController

   > `UIActivityViewController`类是一个标准的`ViewController`，提供了几项标准的服务，比如复制项目至剪贴板，把内容分享至社交网站，以及通过`Messages`发送数据等等。在`iOS 7 SDK`中，`UIActivityViewController`类提供了内置的`AirDrop`功能。

8. App Groups

   > `App Group`用于同一个开发团队开发的`App`之间，包括`App`和`Extension`之间共享同一份读写空间，进行数据共享。同一个团队开发的多个应用之间如果能直接数据共享，大大提高用户体验。

## 1.3 线程

### 定义

> 引自维基百科[线程](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E7%BA%BF%E7%A8%8B)（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。
>
> 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。

讲线程就不能不提任务，任务是什么的，通俗的说任务就是就一件事情或一段代码，线程其实就是去执行这件事情。

> 线程（thread），指的是一个独立的代码执行路径，也就是说线程是代码执行路径的最小分支。在 iOS 中，线程的底层实现是基于 POSIX threads API 的，也就是我们常说的 pthreads ；

### 超线程技术

> 引自维基百科[超线程](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E8%B6%85%E5%9F%B7%E8%A1%8C%E7%B7%92)（HT, Hyper-Threading）超线程技术就是利用特殊的硬件指令，把一个物理内核模拟成两个逻辑内核，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高了CPU的运行速度。 采用超线程即是可在同一时间里，应用程序可以使用芯片的不同部分。

> 引自[知乎](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F30313735%2Fanswer%2F48006772)超线程这个东西并不是开了就一定比不开的好。因为每个CPU核心里ALU，FPU这些运算单元的数量是有限的，而超线程的目的之一就是在一个线程用运算单元少的情况下，让另外一个线程跑起来，不让运算单元闲着。但是如果当一个线程整数，浮点运算各种多，当前核心运算单元没多少空闲了，这时候你再塞进了一个线程，这下子资源就紧张了。两线程就会互相抢资源，拖慢对方速度。至于，超线程可以解决一个线程cache miss，另外一个可以顶上，但是如果两个线程都miss了，那就只有都在等了。这个还是没有GPU里一个SM里很多warp，超多线程同时跑来得有效果。所以，如果你的程序是单线程，关了超线程，免得别人抢你资源，如果是多线程，每个线程运算不大，超线程比较有用。

### 线程池

> [线程池](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fzh-hans%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0)（英语：thread pool）：一种线程使用模式。 线程过多会带来调度开销，进而影响缓存局部性和整体性能。 而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。 这避免了在处理短时间任务时创建与销毁线程的代价。

线程池的执行流程如：
 首先，启动若干数量的线程，并让这些线程处于睡眠状态
 其次，当客户端有新的请求时，线程池会唤醒某一个睡眠线程，让它来处理客户端的请求
 最后，当请求处理完毕，线程又处于睡眠状态

**所以在并发的时候，同时能有多少线程在跑是有线程池的线程缓存数量决定的。**

Tip： <font color='red'>**GCD、NSOPerationQueue线程池最大的线程并发数量默认是`64`个**。</font>

### 任务和队列

**任务**：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：**『同步执行』** 和 **『异步执行』**。两者的主要区别是：**是否等待队列的任务执行结束，以及是否具备开启新线程的能力。**

- 同步执行（sync）：
  - 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。
  - 只能在当前线程中执行任务，不具备开启新线程的能力。
- 异步执行（async）：
  - 异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。
  - 可以在新的线程中执行任务，具备开启新线程的能力。

**队列（Dispatch Queue）**：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：

<img src="https:////upload-images.jianshu.io/upload_images/1877784-01267bd211719167.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom:67%;" />

在 GCD 中有两种队列：**『串行队列』** 和 **『并发队列』**。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：**执行顺序不同，以及开启线程数不同。**

- 串行队列（Serial Dispatch Queue）

  ：

  - 每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）

- 并发队列（Concurrent Dispatch Queue）

  ：

  - 可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）

> 注意：**并发队列** 的并发功能只有在异步（dispatch_async）方法下才有效。





> 
>
> 引自维基百科[队列](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%E9%98%9F%E5%88%97)，又称为伫列（queue），是先进先出（FIFO, First-In-First-Out）的线性表。
>
> 在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。
>  队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。

- 串行队列和并发队列

串行队列：一次只能执行一个任务；

并发队列：允许多个任务同时执行。

`iOS`系统就是使用这些队列来进行任务调度的，它会根据调度任务的需要和系统当前的负载情况动态地创建和销毁线程，而不需要我们手动地管理。

这里会有一个经常性的疑问，串行队列一次执行一个任务，任务按顺序执行，先进先出，这个好理解。**那并发几个任务同时执行也是先进先出，这个怎么理解呢。因为并发执行任务，先进去的任务并不一定先执行完，但是即使后面的任务先执行完，也是要等前面的任务退出。这是由队列的性质决定的。**

注意几个考察点：

* 多个同步任务加入串行队列 （注意：此情况下并没有开辟新的线程，而是使用的当前线程。）
* 多个异步任务加入串行队列 （会开启新的线程）
* 多个同步任务加入并发队列
* 多个异步任务加入并发队列



> > 概念解释：
> >
> > **阻塞与非阻塞**
> >
> > 阻塞/非阻塞， 它们是程序在等待消息(无所谓同步或者异步)时的状态。
> >
> > **A、阻塞**
> >
> > 阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。
> >
> > socket 接收数据函数 recv 是一个阻塞调用的例子。当 socket 工作在阻塞模式的时候， 如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。
> >
> > **B、非阻塞**
> >
> > 非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。
> >
> > **C、对象的阻塞模式和阻塞函数调用**
> >
> > 对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的 API 去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数 select 就是这样的一个例子

#### 

### 线程间通信

线程间通信的表现为：一个线程传递数据给另一个线程；在一个线程中执行完特定任务后，转到另一个线程继续执行任务。(参考：多线程(二))。

## 1.4 面试题

线程与进程的区别：

**线程**是进程的一部分，它是进程中用来**执行任务的单位**。一个进程可以拥有多个线程，但最少要有一个主线程；每个线程不能独立执行，必须有一个父进程；线程可以拥有自己的堆、栈、计数器和局部变量，一个进程里的全部线程会**共享该进程的资源**。线程是独立运行的，一个线程并不知道其它线程的存在，在线程运行过程中随时都有可能被挂起，方便其他线程运行；线程是有优先级的，当然主线程的优先级最高，在我们编程的时候也可以设置线程1执行完毕后才执行线程2。

**进程的并发性：**处理器每次只执行一个进程，然后在多个进程之间快速切换，依次来达到多个进程在单个处理器上同时执行的效果；

**进程的并行性：**同一时刻，处理器同时执行多个进程；

> **多线程与多进程的对比：**
>
> 1.进程之间不能共享内存，线程可以
>
> 同一个进程中的线程共享了改进程的很多资源，包括：进程虚拟空间、进程代码段、进程共有数据等，因此线程之间更容易相互通信，多线程的运行效率远远高于多进程；
>
> 2.系统创建进程的时候要为其分配系统资源，而创建线程则只需要很小一部分，因此多线程比多进程来的更加容易；
>
> 3.多线程可以充分利用处理器（双核或者多核），但是当线程数量达到上限的时候，性能就不在提升了；
>
> 4.多线程的进程中一个线程崩溃了就会导致进程崩溃，如果是主线程崩溃会导致程序崩溃；
>
> 但是多进程中子进程崩溃了不会影响到其它进程，程序稳定性更好；
>
> 5.多线程需要控制线程之间的同步，而多进程则需要控制和主进程之间的交互；
>
> 6.如果两个进程之间要相互传输大量的数据，会相当影响性能，多进程适合小数据量传输，密集运算；



分离式线程

非分离(可会合)式线程

